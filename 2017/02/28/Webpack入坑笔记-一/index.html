<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Jay,362359635@qq.com"><title>Webpack入坑笔记(一) 安装webpack和插件,执行编译任务 · CloudJay's Blog</title><meta name="description" content="随着现在前端工程化技术的发展,各种打包工具和框架层出不穷,我这种老程序猿也要充充电,紧跟时代的发展,否则就要被淘汰了.废话不多说,先从webpack说起.
为什么选择Webpack官网对webpack的定义是MODULE BUNDLER，他的目的就是把有依赖关系的各种文件打包成一系列的静态资源。 请"><meta name="keywords" content="Hexo,HTML,CSS,JavaScript,CloudJay"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?93cbe2c7c0e4e50f9857981ad68ffbb2";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">CloudJay's Blog</a></h3><div class="description"><p>做一个爱游戏爱生活的前端程序猿.</p></div></div></div><ul class="social-links"></ul><div class="footer"><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a><span>+</span><a href="https://github.com/Ben02/hexo-theme-Anatole">Anatole</a><span>&#65281;</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img src="http://ww1.sinaimg.cn/thumbnail/45f387ebgy1fcz7980walj20xc0tb7bi"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Webpack入坑笔记(一) 安装webpack和插件,执行编译任务</a></h3></div><div class="post-content"><p>随着现在前端工程化技术的发展,各种打包工具和框架层出不穷,我这种老程序猿也要充充电,紧跟时代的发展,否则就要被淘汰了.废话不多说,先从webpack说起.</p>
<h1 id="为什么选择Webpack"><a href="#为什么选择Webpack" class="headerlink" title="为什么选择Webpack"></a>为什么选择Webpack</h1><p>官网对webpack的定义是MODULE BUNDLER，他的目的就是把有依赖关系的各种文件打包成一系列的静态资源。 请看下图</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先安装好node和npm,因为webpack是一个基于node的项目,然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> &lt;your project root&gt; //选择你项目所在路径</div><div class="line">npm init //初始化项目,如果你不愿意填写信息,直接一路回车即可</div><div class="line">npm install -g webpack //全局安装webpack,这是为了使用webpack指令更方便,如果单纯的装着项目目录下,则在打webpack指令时需要补全路径</div><div class="line">npm install webpack --dev-save 在项目的package.json中标明该项目依赖webpack</div></pre></td></tr></table></figure>
<p>以上几步做完之后,你的文件夹下应该多出了package.json和node_modules目录</p>
<p>然后你需要新建一个webpack.config.js</p>
<p>webpack.config.js简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分为四大块</p>
<ul>
<li>entry 入口文件 让webpack用哪个文件作为项目的入口</li>
<li>output 出口 让webpack把处理完成的文件放在哪里</li>
<li>module 模块 要用什么不同的模块来处理各种类型的文件</li>
<li>plugins 插件 要使用哪些插件,插件的初始化及配置</li>
</ul>
<p>我们还需要新建一个app目录来存放我们的开发源码</p>
<ul>
<li><p>/app</p>
<ul>
<li>index.js</li>
<li>sub.js</li>
</ul>
</li>
</ul>
<p>以上完成后,我们的目录文件看起来应该是这样的</p>
<ul>
<li><p>/app</p>
<ul>
<li>index.js</li>
<li>sub.js</li>
</ul>
</li>
<li><p>node_modules</p>
</li>
<li><p>package.json</p>
</li>
<li>webpack.config.js</li>
</ul>
<p>接下来我们要在sub.js中编写一个hello world模块,并可以输出到index.js中。webpack原生支持AMD和CommonJS两种标准。也支持ES6，不过我们循序渐进，以后再研究ES6。</p>
<h2 id="sub-js"><a href="#sub-js" class="headerlink" title="sub.js"></a>sub.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//commonjs风格</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateText</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> ele=<span class="built_in">document</span>.createElement(<span class="string">'h2'</span>);</div><div class="line">  ele.innerHTML=<span class="string">'Hello World H2'</span></div><div class="line">  <span class="keyword">return</span> ele;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports=ele;</div></pre></td></tr></table></figure>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><p>然后在 index.js中引用这个模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sub=<span class="built_in">require</span>(<span class="string">'./sub'</span>);</div><div class="line"><span class="keyword">var</span> app=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">app.innerHTML=<span class="string">'Hello World Index'</span>;</div><div class="line">app.appendChild(sub());</div><div class="line"><span class="built_in">document</span>.body.appendChild(app);</div></pre></td></tr></table></figure>
<p>代码写完了,完成了一个很简单的功能,输出一个module,并在index.js中引用他,最后会在页面里输出2个标题,但现在是没办法预览的,因为我们还没有把源码生成为浏览器可以辨识的格式,为了可以在浏览器中访问我们的页面,需要在webpack中对源码进行编译,然后输出.</p>
<h1 id="配置Webpack"><a href="#配置Webpack" class="headerlink" title="配置Webpack"></a>配置Webpack</h1><p>我们的目标是把这2个JS文件合并成一个文件,并输出到 /build/ 目录下,我们可以再build下新建一个index.html,再把合并后的js引用,但这样比较麻烦,所以我们这里引入第一个插件,可以自动快速的帮我们生成HTML.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install html-webpack-plugin --save-dev</div></pre></td></tr></table></figure>
<p>安装好了插件,开始写webpack.config文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> HtmlwebpackPlugin=<span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="comment">//定义一些文件夹的路径</span></div><div class="line"><span class="keyword">var</span> ROOT_PATH=path.resolve(__dirname);</div><div class="line"><span class="keyword">var</span> APP_PATH=path.resolve(ROOT_PATH,<span class="string">'app'</span>);</div><div class="line"><span class="keyword">var</span> BUILD_PATH=path.resolve(ROOT_PATH,<span class="string">'build'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">  <span class="attr">entry</span>:APP_PATH,</div><div class="line">  <span class="attr">output</span>:&#123;</div><div class="line">    <span class="attr">path</span>:BUILD_PATH,</div><div class="line">    <span class="attr">filename</span>:<span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plguins</span>:[</div><div class="line">    <span class="keyword">new</span> HtmlwebpackPlugin(&#123;</div><div class="line">      <span class="attr">title</span>: <span class="string">'Hello World app'</span> <span class="comment">//为新建的HTML页面添加Title</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在项目根目录运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure>
<p>终端会显示一堆信息告诉你成功了,你会发现多出来一个build文件夹,点开里面的index.html会发现”helloword”已经插入到页面了.</p>
<p>上面的任务虽然完成了,但每次都要手动编译并预览页面在真正的开发状态下是不可行的,为此,最好新建一个开发服务器,可以检测我们的代码,当代码更新时自动编译并更新预览.</p>
<p>好在webpack已经有执行相关任务的插件webpack-dev-server,我们只需下载并配置即可</p>
<p>另外,每次要打开浏览器也很麻烦,最好可以一句命令自动打开浏览器,我们还需要安装插件open-browser-webpack-plugin, 在使用open-browser-webpack-plugin时,最新版本有bug会导致和webpack-dev-server冲突,热更新会失效,我们只使用0.0.2老版本</p>
<h2 id="安装webpack-dev-server和open-browser-webpack-plugin"><a href="#安装webpack-dev-server和open-browser-webpack-plugin" class="headerlink" title="安装webpack-dev-server和open-browser-webpack-plugin"></a>安装webpack-dev-server和open-browser-webpack-plugin</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install webpack-dev-server --save-dev</div><div class="line">npm install open-browser-webpack-plugin@0.0.2 --save-dev //指定版本安装插件</div></pre></td></tr></table></figure>
<p>安装完毕后,在webpack.config配置(最新版本已经没有progress选项了)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack=<span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);<span class="comment">//引用path模块</span></div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin=<span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);<span class="comment">//引用自动生成html插件</span></div><div class="line"><span class="keyword">var</span> OpenbrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);<span class="comment">//自动打开浏览器插件</span></div><div class="line"><span class="comment">//定义一些文件夹路径</span></div><div class="line"><span class="keyword">var</span> ROOT_PATH=path.resolve(__dirname);<span class="comment">//__dirname是node.js的一个特殊变量,可以在任意模块内部用来获取当前模块文件所在目录的完整绝对路径</span></div><div class="line"><span class="keyword">var</span> APP_PATH=path.resolve(ROOT_PATH,<span class="string">'app'</span>);</div><div class="line"><span class="keyword">var</span> BUILD_PATH=path.resolve(ROOT_PATH,<span class="string">'build'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">  <span class="comment">//项目的文件夹 可以直接用文件夹名称,默认会找到index.js,也可以指定文件</span></div><div class="line">  entry:APP_PATH,</div><div class="line">  <span class="comment">//输出的文件名,合并以后的JS会命名为bundle.js</span></div><div class="line">  output:&#123;</div><div class="line">    <span class="attr">path</span>:BUILD_PATH,</div><div class="line">    <span class="attr">filename</span>:<span class="string">'./bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">devServer</span>:&#123;</div><div class="line">    <span class="attr">historyApiFallback</span>:<span class="literal">true</span>,</div><div class="line">    <span class="attr">hot</span>:<span class="literal">true</span>,</div><div class="line">    <span class="attr">inline</span>:<span class="literal">true</span>,</div><div class="line">    <span class="attr">port</span>: <span class="number">8080</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">//添加我们的插件,会自动生成一个html文件</span></div><div class="line">  plugins:[</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">title</span>:<span class="string">'Hello World app --Title'</span>&#125;),</div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</div><div class="line">    <span class="keyword">new</span> OpenbrowserPlugin(&#123;<span class="attr">url</span>:<span class="string">'http://localhost:8080'</span>,<span class="attr">browser</span>:<span class="string">"firefox"</span>,<span class="attr">ignoreErrors</span>:<span class="literal">true</span>&#125;)<span class="comment">//该插件必须使用0.0.2版本,否则会导致无法热刷新</span></div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在package.json里配置一下运行命令,npm支持自定义命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></div><div class="line">&#125;,</div><div class="line">...</div></pre></td></tr></table></figure>
<p>好了,现在所有的配置都好了,在项目根目录下输入 npm start,经过一段时间的编译,server已经启动,并自动打开了浏览器, 我们又见到了亲爱的”hello word”,在JS里随便修改一些输出,然后保存,浏览器自动刷新,效果实现了!</p>
<blockquote>
<p>参考知识:<a href="https://zhuanlan.zhihu.com/p/20367175?columnSlug=FrontendMagazine" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20367175?columnSlug=FrontendMagazine</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-02-28</span><i class="fa fa-comment-o"></i><a href="/2017/02/28/Webpack入坑笔记-一/#comments">评论</a><i class="fa fa-tag"></i><a href="/tags/webpack-js模块化/" title="webpack js模块化" class="tag">webpack js模块化 </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://blog.cloudjay.net/2017/02/28/Webpack入坑笔记-一/,CloudJay's Blog,Webpack入坑笔记(一) 安装webpack和插件,执行编译任务,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/03/01/20170301/" title="Webpack入坑笔记(二) 小图片优化,引入CSS,使用ES6" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/02/04/Windows系统下使用Hexo并部署到GitHub/" title="Windows系统下使用Hexo并部署到GitHub" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div data-thread-key="2017/02/28/Webpack入坑笔记-一/" data-title="Webpack入坑笔记(一) 安装webpack和插件,执行编译任务" data-url="http://blog.cloudjay.net/2017/02/28/Webpack入坑笔记-一/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"cloudjay"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>